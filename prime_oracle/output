; SMT 2
; Generated for Z3
(set-info :source "generated by emu")
(set-option :produce-models true)

; find_symbols
(declare-fun |multiplier| () Int)
; set_to true
(assert (>= |multiplier| 1))

; find_symbols
(declare-fun |x| () Int)
; set_to true
(assert (>= |x| 1))

; find_symbols
(declare-fun |y| () Int)
; set_to true
(assert (>= |y| 1))

; set_to true (equal)
(define-fun |n| () Int (* 2 |multiplier|))

; find_symbols
(declare-fun |isPrime| (Int )Bool)
; set_to true (equal)
(define-fun |H0| () Bool (isPrime |x| ))

; set_to true (equal)
(define-fun |H1| () Int |x|)

; set_to true
(assert (isPrime |x| ))

; set_to true (equal)
(define-fun |H2| () Bool (isPrime |y| ))

; set_to true (equal)
(define-fun |H3| () Int |y|)

; set_to true
(assert (isPrime |y| ))

; set_to true
(assert (= (+ |x| |y|) |n|))
; Found satisfing counterexample 

; SMT 2
; Generated for Z3
(set-info :source "generated by emu for negation solver")
(set-option :produce-models true)

; find_symbols
(declare-fun |multiplier| () Int)
; set_to false
(assert (not (>= |multiplier| 1)))

; find_symbols
(declare-fun |x| () Int)
; set_to false
(assert (not (>= |x| 1)))

; find_symbols
(declare-fun |y| () Int)
; set_to false
(assert (not (>= |y| 1)))

; find_symbols
(declare-fun |n| () Int)
; set_to false
(assert (not (= |n| (* 2 |multiplier|))))

; find_symbols
(declare-fun |isPrime| (Int )Bool)
; set_to true (equal)
(define-fun |H0| () Bool (isPrime |x| ))

; set_to true (equal)
(define-fun |H1| () Int |x|)

; set_to false
(assert (not (isPrime |x| )))

; set_to true (equal)
(define-fun |H2| () Bool (isPrime |y| ))

; set_to true (equal)
(define-fun |H3| () Int |y|)

; set_to false
(assert (not (isPrime |y| )))

; set_to false
(assert (not (= (+ |x| |y|) |n|)))
; negation witness 

; checking oracle app, use negation oracle 1
; input 0
; Running oracle (verification)  primes 0
; oracle response false
; checking oracle app, use negation oracle 1
; input (- 1)
; Running oracle (verification)  primes -1
; oracle response false
; SMT 2
; Generated for Z3
(set-info :source "generated by emu")
(set-option :produce-models true)

; find_symbols
(declare-fun |multiplier| () Int)
; set_to true
(assert (>= |multiplier| 1))

; find_symbols
(declare-fun |x| () Int)
; set_to true
(assert (>= |x| 1))

; find_symbols
(declare-fun |y| () Int)
; set_to true
(assert (>= |y| 1))

; set_to true (equal)
(define-fun |n| () Int (* 2 |multiplier|))

; find_symbols
(declare-fun |isPrime| (Int )Bool)
; set_to true (equal)
(define-fun |H0| () Bool (isPrime |x| ))

; set_to true (equal)
(define-fun |H1| () Int |x|)

; set_to true
(assert (isPrime |x| ))

; set_to true (equal)
(define-fun |H2| () Bool (isPrime |y| ))

; set_to true (equal)
(define-fun |H3| () Int |y|)

; set_to true
(assert (isPrime |y| ))

; set_to true
(assert (= (+ |x| |y|) |n|))

; set_to true
(assert (=> (= |H3| 0) (= |H2| false)))

; set_to true
(assert (=> (= |H1| -1) (= |H0| false)))
; Found satisfing counterexample 

; SMT 2
; Generated for Z3
(set-info :source "generated by emu for negation solver")
(set-option :produce-models true)

; find_symbols
(declare-fun |multiplier| () Int)
; set_to false
(assert (not (>= |multiplier| 1)))

; find_symbols
(declare-fun |x| () Int)
; set_to false
(assert (not (>= |x| 1)))

; find_symbols
(declare-fun |y| () Int)
; set_to false
(assert (not (>= |y| 1)))

; find_symbols
(declare-fun |n| () Int)
; set_to false
(assert (not (= |n| (* 2 |multiplier|))))

; find_symbols
(declare-fun |isPrime| (Int )Bool)
; set_to true (equal)
(define-fun |H0| () Bool (isPrime |x| ))

; set_to true (equal)
(define-fun |H1| () Int |x|)

; set_to false
(assert (not (isPrime |x| )))

; set_to true (equal)
(define-fun |H2| () Bool (isPrime |y| ))

; set_to true (equal)
(define-fun |H3| () Int |y|)

; set_to false
(assert (not (isPrime |y| )))

; set_to false
(assert (not (= (+ |x| |y|) |n|)))

; set_to true
(assert (=> (= |H3| 0) (= |H2| false)))

; set_to true
(assert (=> (= |H1| -1) (= |H0| false)))
; negation witness 

; checking oracle app, use negation oracle 1
; input 0
historical oracle cal
; seen this oracle call before
; checking oracle app, use negation oracle 1
; input (- 1)
historical oracle cal
; seen this oracle call before
; SMT 2
; Generated for Z3
(set-info :source "generated by emu")
(set-option :produce-models true)

; find_symbols
(declare-fun |multiplier| () Int)
; set_to true
(assert (>= |multiplier| 1))

; find_symbols
(declare-fun |x| () Int)
; set_to true
(assert (>= |x| 1))

; find_symbols
(declare-fun |y| () Int)
; set_to true
(assert (>= |y| 1))

; set_to true (equal)
(define-fun |n| () Int (* 2 |multiplier|))

; find_symbols
(declare-fun |isPrime| (Int )Bool)
; set_to true (equal)
(define-fun |H0| () Bool (isPrime |x| ))

; set_to true (equal)
(define-fun |H1| () Int |x|)

; set_to true
(assert (isPrime |x| ))

; set_to true (equal)
(define-fun |H2| () Bool (isPrime |y| ))

; set_to true (equal)
(define-fun |H3| () Int |y|)

; set_to true
(assert (isPrime |y| ))

; set_to true
(assert (= (+ |x| |y|) |n|))

; set_to true
(assert (=> (= |H3| 0) (= |H2| false)))

; set_to true
(assert (=> (= |H1| -1) (= |H0| false)))
; Found satisfing counterexample 

; Running oracle (verification)  primes 1
; oracle response false
; Response does not match true
; Running oracle (verification)  primes 77
; oracle response false
; Response does not match true
; SMT 2
; Generated for Z3
(set-info :source "generated by emu for negation solver")
(set-option :produce-models true)

; find_symbols
(declare-fun |multiplier| () Int)
; set_to false
(assert (not (>= |multiplier| 1)))

; find_symbols
(declare-fun |x| () Int)
; set_to false
(assert (not (>= |x| 1)))

; find_symbols
(declare-fun |y| () Int)
; set_to false
(assert (not (>= |y| 1)))

; find_symbols
(declare-fun |n| () Int)
; set_to false
(assert (not (= |n| (* 2 |multiplier|))))

; find_symbols
(declare-fun |isPrime| (Int )Bool)
; set_to true (equal)
(define-fun |H0| () Bool (isPrime |x| ))

; set_to true (equal)
(define-fun |H1| () Int |x|)

; set_to false
(assert (not (isPrime |x| )))

; set_to true (equal)
(define-fun |H2| () Bool (isPrime |y| ))

; set_to true (equal)
(define-fun |H3| () Int |y|)

; set_to false
(assert (not (isPrime |y| )))

; set_to false
(assert (not (= (+ |x| |y|) |n|)))

; set_to true
(assert (=> (= |H3| 0) (= |H2| false)))

; set_to true
(assert (=> (= |H1| -1) (= |H0| false)))
; negation witness 

; checking oracle app, use negation oracle 1
; input 0
historical oracle cal
; seen this oracle call before
; checking oracle app, use negation oracle 1
; input (- 1)
historical oracle cal
; seen this oracle call before
; SMT 2
; Generated for Z3
(set-info :source "generated by emu")
(set-option :produce-models true)

; find_symbols
(declare-fun |multiplier| () Int)
; set_to true
(assert (>= |multiplier| 1))

; find_symbols
(declare-fun |x| () Int)
; set_to true
(assert (>= |x| 1))

; find_symbols
(declare-fun |y| () Int)
; set_to true
(assert (>= |y| 1))

; set_to true (equal)
(define-fun |n| () Int (* 2 |multiplier|))

; find_symbols
(declare-fun |isPrime| (Int )Bool)
; set_to true (equal)
(define-fun |H0| () Bool (isPrime |x| ))

; set_to true (equal)
(define-fun |H1| () Int |x|)

; set_to true
(assert (isPrime |x| ))

; set_to true (equal)
(define-fun |H2| () Bool (isPrime |y| ))

; set_to true (equal)
(define-fun |H3| () Int |y|)

; set_to true
(assert (isPrime |y| ))

; set_to true
(assert (= (+ |x| |y|) |n|))

; set_to true
(assert (=> (= |H3| 0) (= |H2| false)))

; set_to true
(assert (=> (= |H1| -1) (= |H0| false)))

; set_to true
(assert (=> (= |H3| 1) (= |H2| false)))

; set_to true
(assert (=> (= |H1| 77) (= |H0| false)))
; Found satisfing counterexample 

; Running oracle (verification)  primes 2
; oracle response true
; Response matches true
historical oracle cal
; Response matches true
; consistent with oracles, problem is sat

sat
((define-fun n () Int 4)
 (define-fun x () Int 2)
 (define-fun y () Int 2)
 (define-fun multiplier () Int 2))
